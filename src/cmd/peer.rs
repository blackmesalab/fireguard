use clap::Clap;
use color_eyre::eyre::Result;

use crate::cmd::{Command, Fireguard};
use crate::config::{Config, Peer as ConfigPeer};
use crate::ip::IpPool;
use crate::wg::key::WgKeys;

/// Peer - peers management for a trust repository
#[derive(Clap, Debug)]
pub struct Peer {
    /// Peer subcommands
    #[clap(subcommand)]
    pub action: Action,
    /// Repository name
    #[clap(short = 'r', long = "repository")]
    pub repository: String,
}

#[derive(Clap, Debug)]
pub enum Action {
    /// List the available peers in this trust repository
    List(List),
    /// Add a new peer
    Add(Add),
    /// Remove an existing peer
    Remove(Remove),
    /// Print peer info
    Info(Info),
}

impl Command for Peer {}
impl Peer {
    pub async fn exec(&self, fg: &Fireguard) -> Result<()> {
        let config = self.load_config(&self.repository, &fg.config_dir, &fg.config_file).await?;
        match self.action {
            Action::List(ref action) => action.exec(fg, config, &self.repository).await?,
            Action::Add(ref action) => action.exec(fg, config, &self.repository).await?,
            Action::Remove(ref action) => action.exec(fg, config, &self.repository).await?,
            Action::Info(ref action) => action.exec(fg, config, &self.repository).await?,
        }
        Ok(())
    }
}

/// List the available peers in this trust repository
#[derive(Clap, Debug)]
pub struct List {
    /// Repository name
    #[clap(short = 'r', long = "repository")]
    pub repository: String,
}

impl Command for List {}
impl List {
    pub async fn exec(&self, fg: &Fireguard, _config: Config, repository: &str) -> Result<()> {
        let config = self.load_config(repository, &fg.config_dir, &fg.config_file).await?;
        info!("Available peers in {}: {:?}", repository, config.peers.keys());
        Ok(())
    }
}

/// Add a new peer to the repository
#[derive(Clap, Debug)]
pub struct Add {
    /// User name
    #[clap(short = 'u', long = "username")]
    pub username: String,
    /// Peer name
    #[clap(short = 'p', long = "peername")]
    pub peername: String,
    /// Peer listen port
    #[clap(short = 'P', long = "port", default_value = "0")]
    pub port: u32,
    /// Peer keep alive in seconds
    #[clap(short = 'k', long = "keep-alive", default_value = "0")]
    pub keep_alive: u32,
    /// Allowed IPs
    #[clap(short = 'a', long = "allowed-ips")]
    pub allowed_ips: Option<Vec<String>>,
    /// Peer public endpoint if there is public connectivity
    #[clap(short = 'e', long = "endpoint")]
    pub endpoint: Option<String>,
    /// Public key, autogenerated if empty
    #[clap(short = 'K', long = "public-key")]
    pub public_key: Option<String>,
    /// MTU, default 1500
    #[clap(short = 'm', long = "mtu", default_value = "1500")]
    pub mtu: u32,
    /// Force add even if the peer already exists
    #[clap(short = 'f', long = "force")]
    pub force: bool,
}

impl Command for Add {}
impl Add {
    pub async fn exec(&self, fg: &Fireguard, mut config: Config, repository: &str) -> Result<()> {
        let peername = format!("{}-{}", self.username, self.peername);
        if config.get_peer(&peername).is_none() || self.force {
            if self.force {
                info!("Forcing override of peer {}-{} in repository {}", self.username, self.peername, repository);
                self.build_peer(fg, &mut config, repository).await?;
            }
            let peer = Info { username: self.username.clone(), peername: self.peername.clone() };
            peer.exec(fg, config, repository).await?;
        } else {
            warn!(
                "Peer {}-{} already exists in repository {}. Use -f/--force to override it",
                self.username, self.peername, repository
            )
        }
        Ok(())
    }

    async fn build_peer(&self, fg: &Fireguard, config: &mut Config, repository: &str) -> Result<()> {
        let keys: WgKeys;
        if let Some(pkey) = self.public_key.as_ref() {
            keys = WgKeys::new(pkey, "");
        } else {
            keys = WgKeys::generate().await?;
        }
        info!(
            "Generated public key for {}, username: {}, peername: {}: {}",
            repository, self.username, self.peername, keys.public
        );
        let mut pool = IpPool::new(&config.network, config.get_peers_ips())?;
        let peer = ConfigPeer::new(
            &self.username,
            &self.peername,
            &format!("{}/{}", pool.ip()?, config.network_addr.prefix_len()),
            self.port,
            &keys.public,
            self.allowed_ips.as_ref().unwrap_or(&Vec::new()),
            self.keep_alive,
            self.endpoint.clone(),
            self.mtu,
            None,
            None,
            None,
            None,
            None,
        );
        debug!("Peer {}-{} will be added to repository {}:\n{:#?}", self.username, self.peername, repository, peer);
        config.add_peer(&format!("{}-{}", self.username, self.peername), peer);
        config.save(&self.config_file(repository, &fg.config_dir, &fg.config_file)).await?;
        Ok(())
    }
}

/// Remove one peer from this trust repository
#[derive(Clap, Debug)]
pub struct Remove {
    /// User name
    #[clap(short = 'u', long = "username")]
    pub username: String,
    /// Peer name
    #[clap(short = 'p', long = "peername")]
    pub peername: String,
}

impl Command for Remove {}
impl Remove {
    pub async fn exec(&self, _fg: &Fireguard, mut config: Config, repository: &str) -> Result<()> {
        let peer = config.remove_peer(&format!("{}-{}", self.username, self.peername));
        match peer {
            Some(_) => {
                info!("Peer {}-{} removed from repository {}", self.username, self.peername, repository);
            }
            None => {
                warn!("Peer {}-{} not found in repository {}", self.username, self.peername, repository);
            }
        }
        Ok(())
    }
}

/// Print the info of a peer from this trust repository
#[derive(Clap, Debug)]
pub struct Info {
    /// User name
    #[clap(short = 'u', long = "username")]
    pub username: String,
    /// Peer name
    #[clap(short = 'p', long = "peername")]
    pub peername: String,
}

impl Command for Info {}
impl Info {
    pub async fn exec(&self, fg: &Fireguard, config: Config, repository: &str) -> Result<()> {
        let peer = config.get_peer(&format!("{}-{}", self.username, self.peername));
        match peer {
            Some(peer) => {
                config.save(&self.config_file(repository, &fg.config_dir, &fg.config_file)).await?;
                info!("Peer {}-{}, repository {}:\n{:#?}", self.username, self.peername, repository, peer);
            }
            None => {
                warn!("Peer {}-{} not found in repository {}", self.username, self.peername, repository);
            }
        }
        Ok(())
    }
}
