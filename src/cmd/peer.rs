use std::net::Ipv4Addr;

use clap::Clap;
use eyre::{bail, Result};
use read_input::prelude::*;

use crate::cmd::{Command, CommandLine};
use crate::config::Peer as ConfigPeer;
use crate::ip::IpPool;
use crate::wg::key::WgKeys;

/// Peer - peers management for a trust repository
#[derive(Clap, Debug)]
pub struct Peer {
    /// Peer subcommands
    #[clap(subcommand)]
    pub action: Action,
    /// Repository name
    #[clap(short = 'r', long = "repository")]
    pub repository: String,
}

#[derive(Clap, Debug)]
pub enum Action {
    /// List the available peers in this trust repository
    List(List),
    /// Add a new peer
    Add(Add),
    /// Remove an existing peer
    Remove(Remove),
}

impl Command for Peer {}
impl Peer {
    pub fn exec(&self, cmd: &CommandLine) -> Result<()> {
        match self.action {
            Action::List(ref action) => action.exec(cmd, &self.repository)?,
            Action::Add(ref action) => action.exec(cmd, &self.repository)?,
            Action::Remove(ref action) => action.exec(cmd, &self.repository)?,
        }
        Ok(())
    }
}

/// List the available peers in this trust repository
#[derive(Clap, Debug)]
pub struct List {
    /// Repository name
    #[clap(short = 'r', long = "repository")]
    pub repository: String,
}

impl Command for List {}
impl List {
    pub fn exec(&self, cmd: &CommandLine, repository: &str) -> Result<()> {
        let config = self.load_config(&cmd.config, repository)?;
        info!("Available peers in {}: {:?}", repository, config.peers.keys());
        Ok(())
    }
}

/// Add a new peer to the repository
#[derive(Clap, Debug)]
pub struct Add {
    /// User name
    #[clap(short = 'u', long = "username")]
    pub username: String,
    /// Peer name
    #[clap(short = 'p', long = "peername")]
    pub peername: String,
    /// Peer listen port  
    #[clap(short = 'P', long = "port", parse(from_occurrences))]
    pub port: u32,
    /// Peer keep alive in seconds
    #[clap(short = 'k', long = "keep-alive", parse(from_occurrences), default_value = "0")]
    pub keep_alive: u32,
    /// Allowed IPs
    #[clap(short = 'a', long = "allowed-ips")]
    pub allowed_ips: Option<Vec<String>>,
    /// Peer public endpoint if there is public connectivity  
    #[clap(short = 'e', long = "endpoint")]
    pub endpoint: Option<String>,
    /// Public key, autogenerated if empty
    #[clap(short = 'K', long = "public-key")]
    pub public_key: Option<String>,
}

impl Command for Add {}
impl Add {
    pub fn exec(&self, cmd: &CommandLine, repository: &str) -> Result<()> {
        let keys: WgKeys;
        if let Some(pkey) = self.public_key.as_ref() {
            keys = WgKeys::new(pkey, "");
        } else {
            keys = WgKeys::generate()?;
        }
        info!(
            "Generated public key for {}, username: {}, peername: {}: {}",
            repository, self.username, self.peername, keys.public
        );
        let mut config = self.load_config(&cmd.config, repository)?;
        let mut pool = IpPool::new(&config.network, config.get_peers_ips())?;
        let peer = ConfigPeer::new(
            &self.username,
            &self.peername,
            &format!("{}/{}", pool.ip()?, config.network_addr.prefix_len()),
            self.port,
            &keys.public,
            self.allowed_ips.as_ref().unwrap_or(&Vec::new()),
            self.keep_alive,
            self.endpoint.clone(),
        );
        info!("Adding new peer {}-{} to repository {}:\n{:#?}", self.username, self.peername, repository, peer);
        config.add_peer(&format!("{}-{}", self.username, self.peername), peer);
        config.save(&self.config_file(&cmd.config, repository))?;
        Ok(())
    }
}

/// List the available peers in this trust repository
#[derive(Clap, Debug)]
pub struct Remove {
    /// User name
    #[clap(short = 'u', long = "username")]
    pub username: String,
    /// Peer name
    #[clap(short = 'p', long = "peername")]
    pub peername: String,
}

impl Command for Remove {}
impl Remove {
    pub fn exec(&self, cmd: &CommandLine, repository: &str) -> Result<()> {
        let mut config = self.load_config(&cmd.config, repository)?;
        let peer = config.remove_peer(&format!("{}-{}", self.username, self.peername));
        match peer {
            Some(peer) => {
                config.save(&self.config_file(&cmd.config, repository))?;
                info!("Removed peer {}-{} from repository {}:\n{:#?}", self.username, self.peername, repository, peer);
            }
            None => {
                warn!("Peer {}-{} not found in repository {}", self.username, self.peername, repository);
            }
        }
        Ok(())
    }
}
